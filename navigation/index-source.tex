\section{Indexer ses sources}


Nous allons maintenant voir comment utiliser les possibilités de \package{biblatex} et de \package{splitindex} pour établir un index des sources primaires.

Pour comprendre cette section, vous devez vous êtes familiarisé avec les indications sur les macros bibliographiques.



\subsection{Premier essai}

La documentation de \package{biblatex}\footcite{biblatex_options} nous informe qu'il existe  au chargement du package une option \option{indexing} qui permet d'indexer automatiquement les références bibliographiques. Comme nous nous souhaitons indexer que lors des appels aux commandes \cs{PREFIXcite}  ---  non pas lors de l'appel à la commande \cs{printbibliography} --- nous donnons la valeur \contenuarg{cite} à cette option. 

\begin{minted}{latex}
\usepackage[indexing=cite]{biblatex}
\end{minted}

Étant donné qu'il faut à la fois interpréter le fichier \ext{bib} et faire un index, nous devons procéder aux compilations dans l'ordre suivant :

\begin{enumerate}
\item Compilation avec \XeLaTeX.
\item Compilation avec Biber (ou BibTeX).
\item Compilation avec \XeLaTeX pour que les données bibliographiques soit intégrées dans l'index.
\item Compilation avec Makeindex pour transformer le fichier \ext{idx} en \ext{ind}.
\item Compilation avec \XeLaTeX pour finir d'intégrer l'index dans le fichier \ext{pdf}
\end{enumerate}

On constate cependant deux problèmes : 
\begin{enumerate}
\item La bibliographie se trouve mêlées aux autres entrées de l'index.
\item Plus grave : aux lieux d'avoir des entrées sous la forme : \verb|Auteur!Titre|, nous avons des entrées pour les auteurs et des entrées pour les sources.
\end{enumerate}

En outre nous aimerions :
\begin{enumerate}
\item Limiter l'indexation aux sources primaires.
\item Indexer aussi, comme troisième niveau d'index, le champ \champ{titleaddon} qui nous sert pour les division de source. \renvoi{divisionsource}
\end{enumerate}

\subsection{Création d'un index spécifique}

Pour créer un index spécifique aux sources, rien de particulier : il suffit d'utiliser \package{splitindex} et la commande suivante :
\begin{minted}{latex}
\newindex[Index des sources]{sources}
\end{minted}

\subsection{Modifications des macros de \packagenoidx{BibLaTeX}}\sindex[pkg]{BibLaTeX}

Nous avons donc notre index spécifique. Mais encore faut-il que nous disions  à \package{biblatex} d'y écrire son index. Pour ce faire nous allons d'abord redéfinir la macro \bibmacro{citeindex} qui est appelée à chaque commande \cs{PREFIXcite}.

\inputminted{exemples/navigation/index-source/citeindex.tex}

\begin{description}
\item[ligne 2]la commande \cs{ifciteindex} vérifier que l'option \option{indexing} de \package{biblatex} est bien égale à \verb|true| ou bien à \verb|cite|. Ce qui suit entre accolades est exécuté dans ce cas.
\item[ligne 3]nous indexons le champ \champ{author}.  Nous utilisons le format d'indexation \verb|sources|.
\item[ligne4]nous indexons le champ \champ{indextitle}. Si ce champ est vide \package{BibLaTeX} utilise à la place le champ \champ{title}. Nous utilisons le format d'indexation \verb|sources|.
\item[ligne 5]nous indexons le champ \champ{titleaddon}. Nous utilisons le format d'indexation \verb|sources|.
\item[ligne 6]nous indexons la valeur \verb|---| dans le fichier \fichier{xxx-source.idx}. Cette valeur servira plus tard lors de l'exécution d'un script python.\renvoi{python}. En effet, une des limitations de biblatex est qu'il ne peut indexer qu'un seul champ à la fois, et n'est pas capable, pour le moment, de produire des entrées d'index du type \cs{index}\marg{Champ1!Champ2!Champ3}. Pour contourner cela, nous avons conçu un script qui concaténe dans le fichier \ext{idx} trois indexations en une seule indexation. Pour que ce script ne concaténe pas ensemble des indexations qui ne doivent pas être concaténée, nous écrivons des fausses indexations sous la forme \verb|---|, qui serviront de point de repère au script.
\end{description}

\subsection{Fomat d'indexation \packagenoidx{BibLaTeX}}\sindex[pkg]{BibLaTeX}

Nous avons dit que nous utilisions les formats d'indexation \forme{source}. Un format d'indexation \package{BibLaTeX}  est simplement une description de l'opération que \package{BibLaTeX} effectue lorsqu'il doit indexer un champ. 

Il nous faut donc définir ce format. 

\subsubsection{Indexation des noms}

\begin{minted}{latex}
\DeclareIndexNameFormat{sources}{%
  \usebibmacro{index:name}{\sindex[sources]}{#1}{#3}{#5}{#7}
  }
\end{minted}

Nous disions en première ligne que nous déclarions un format d'indexation \verb|sources| pour les noms propres. Dans la ligne suivante, nous déclarons ce que nous faisons : nous appelons une macro \bibmacro{index:name}. Cette macro est déjà définie par \package{biblatex}. Elle reçoit plusieurs argument. Le première argument est la commande à exécuter : ici \cs{sindex}\verb|[sources]|, qui permet d'indexer dans l'index \verb|source| définis plus haut. Les autres arguments sont repris des codes de \package{biblatex} est désigne les différentes parties du nom à indexer\footcite[Nous renvoyons le lecteur à la documentation de \package{BibLaTeX} : ][]{biblatex_formats}.


\subsubsection{Indexation des autres champs}

\begin{minted}{latex}
\DeclareIndexFieldFormat{sources}{%
  \ifcurrentfield{indextitle}{\sindex[sources]{#1@\emph{#1}}}%
  {\sindex[sources]{#1}}%
  }
\end{minted}

La commande \cs{DeclareIndexFiledFormat} sert à déclarer la manière d'indexer le champs qui ne sont ni des listes ni des noms. La valeur \verb|#1| correspond à la valeur du champ à indexer. En deuxième ligne, nous vérifions que le champ à indexer à est \champ{indextitle} : si c'est le cas, nous l'indexons dans l'index \forme{source} en mettant l'emphase sur le titre pour l'affichage final. Sinon, nous l'indexons simplement dans l'index \forme{source}.

\subsection{Compilation et concaténation des index}


Après la  compilation \XeLaTeX, nous obtenons un fichier \fichier{xxx.idx}. Si vous l'ouvrez vous constatez que nous avons des entrées sous la forme : 

\begin{minted}{latex}
\indexentry[sources]{Author}{page}
\indexentry[sources]{Titleindex@\emph  {Titleindex}}{page}
\indexentry[sources]{Titleaddon}{page}
\indexentry[sources]{---}{page}
\end{minted}

Nous souhaitons remplacé ces entrées par des entrées sous la forme 

\begin{minted}{latex}
\indexentry[sources]{Author@Author!Titleindex@\emph  {Titleindex}!Titleaddon@Titleaddon}{page}
\end{minted}

L'auteur de ces lignes a développé un script permettant d'automatiser cette transformation. Par ailleurs ce script modifie également l'ordre des tri pour ne pas tenir compte des accents.

Pour utiliser ce script, il vous faut :\label{python}
\begin{itemize}
\item Avoir le logiciel Python installé sur votre ordinateur. Ce logiciel est installé en standard sous Mac Os X et sur la plupart des distributions Linux, mais pas sous Windows\footcite{python_windows}.
\item Télécharger le script sur le site de l'auteur à la l'adresse suivante : \url{http://geekographie.maieul.net/57}.
\item Mettre ce fichier dans le répertoire de notre fichier \ext{idx}. 
\item L'ouvrir et modifier la ligne 8 en remplaçant \verb|xxx.idx| par le nom du fichier à concaténer.
\item En ligne de commande se rendre dans le  répertoire, puis taper l'entrée : \verb|python index.py|.
\end{itemize}


Après cette concaténation nous devons compiler en ligne de commande, enfin de séparer les différents index :
\begin{minted}{bash}
splitindex xxx
\end{minted}


\subsection{Raffinement}

Nous souhaitons n'indexer que les sources primaires. La solution la plus simple est d'utiliser dans le fichier \ext{bib} un champ personnalisé \champ{usera}. BibLaTeX permet en effet à l'utilisateur d'utiliser librement un certain nombre de champ\footcite[La liste de ces champs est fourni dans][]{biblatex_custom_fields}.  Dans ce champ, mettre 1 si l'entrée est une source primaire, 2 si l'entrée est une source secondaire.

Il nous suffit de modifier la macro \bibmacro{citeindex}, en introduisant un test (ligne 2) sur la valeur du champ \champ{usera}.
\inputminted{exemples/navigation/index-source/citeindex-usera.tex}

\subsection{Résumé des diverses compilations}

Pour obtenir un index des sources primaires, une fois tout les fichiers mis en place, il nous faut donc procéder dans le terminal aux opérations suivantes :
\begin{itemize}
\item \verb|xelatex xxx.tex|
\item \verb|biber xxx|
\item \verb|xelatex xxx.tex|\footnote{Si un sommaire se situe en début d'ouvrage, il peut être nécéssaire de compiler plusieurs fois.}
\item \verb|python index.py|
\item \verb|splitindex xxx|
\item \verb|xelatex xxx|
\end{itemize}

\begin{anedocte}
Évidemment, l'ensemble de ces opérations peut être fastidieuse à se souvenir, à refaire etc. C'est pourquoi il est conseillé, pour les personnes travaillant sous Linux et Mac Os X d'utiliser un programme nommé make\footnote{Pour les utilisateurs de Windows, il est possible, moyennant certaines techniques, d'installer ce programme.}. 

L'idée du programme make est de décrire dans un fichier les opérations nécessaires au passage d'un ensemble de fichier a vers un fichier b. Le programme make exécute ces opérations uniquement si les fichiers a ont été modifiés. En outre make permet de faire des tests pour éviter de compiler deux fois si cela n'est pas utile. Notre livre n'est pas assez long pour expliquer comment se servir de make. Nous renvoyons à d'autres travaux\footcite[On pourra consulter, par exemple :][]{makefile}.
\end{anedocte}
